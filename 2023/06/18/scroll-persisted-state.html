<!doctype html>
<html>
  <head>
      <meta charset=utf-8>
      <title>Scroll-persisted State</title>
      <style>@layer reset, default, layout;</style>
      <link rel=stylesheet href=/assets/css/reset.css>
      <link rel=stylesheet href=/assets/css/fonts.css>
      <link rel=stylesheet href=/assets/css/default.css>
      <link rel=stylesheet href=/assets/css/layout.css>
      <link rel=stylesheet href=/assets/css/style.css>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel=canonical href="https://odland.dev/2023/06/18/scroll-persisted-state.html">
      <meta http-equiv="refresh" content="0; url=https://odland.dev/2023/06/18/scroll-persisted-state.html" />
      <link rel="me" href="https://front-end.social/@johannes">
  </head>
  <body>
  
   <header>
      <a href="/" class="site-title">Johannes Odland</a>
      <nav></nav>
    </header>

    <article role="main">
      <header>
        <time datetime="Sun Jun 18 2023 21:00:00 GMT+0000 (Coordinated Universal Time)" pubdate>
          Jun 18, 2023
        </time>
        <h1>Scroll-persisted State</h1>
      </header>
      <div class="content"><style>
    .has-support-info {
        display: block;
        background: floralwhite;
        border: 2px solid lemonchiffon;
        padding: 10px;
    }
    @supports (animation-timeline: view()) and (timeline-scope: --some-ident) {
        .has-support-info {
            display: none;
        }
    }
</style>
<p>While working on another article, I stumbled upon a fascinating discovery:
a way to manipulate and read state solely through style rules using HTML and CSS.</p>
<p>This admittedly outrageous hack builds upon one realization: Scroll containers can hold state in their scroll position.
This state can be set using scroll-snap, and read using scroll-driven animations.</p>
<p><strong>We can use a single div with style rules to write, store and read a state.</strong></p>
<p><strong>⚠️ Important Note:</strong> This technique I’m about to describe is an experimental, admittedly outrageous hack.
While it’s an intriguing concept and might open up new possibilities for CSS and HTML,
it’s not recommended to use this in a production environment.
To stress this point: this is a hack. It might never be “production-ready” as we typically understand it.</p>
<p>It’s worth noting that this technique – and the examples provided below – currently work exclusively in Chrome Canary
and other browsers that support scroll-driven animations.
Also, it’s important to acknowledge that the implications of this technique on accessibility and performance have not been investigated.
Please treat it as a fascinating discovery and a basis for further exploration rather than a ready-to-go solution.</p>
<p><strong>Ideally, we’d have a formalized feature akin to the proposed CSS Toggles,
as detailed in this <a href="https://github.com/w3c/csswg-drafts/issues/6991">GitHub issue</a> and <a href="https://tabatkins.github.io/css-toggle/#terminology">unofficial proposal draft</a> by Tab Atkins Jr. and Miriam E. Suzanne.</strong></p>
<p>Let’s dive into the details.</p>
<h2>Maintaining state</h2>
<p>Storing state can be achieved by using a simple <code>&lt;div&gt;</code> element,
and converting it into a scroll container using <code>overflow-x: scroll</code>.
To give it scrollable overflow, we add a pseudo-element to the div,
placing it just outside the scroll-port.</p>
<p>The scroll position constitutes our state.
Specifically, the scroll container is in one state when scrolled to the start, and another when scrolled to the end.
Visually, the state element takes on a red background color when the container is scrolled to the start,
and transitions to green when scrolled to the end.</p>
<p><em>Note: Here, our scroll position holds a binary state - at the start or at the end.
But with the use of multiple snap points, it’s possible to switch between more than two values</em></p>
<figure id="example-1">
    <div class="state"></div>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        #example-1 .state {
            display: flex;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            overflow-x: scroll;
            scrollbar-width: none;
            background: red;
            margin: 10px;
            font-size: 16px;
            line-height: 20px;
            color: white;
        }
        #example-1 .state::before, 
        #example-1 .state::after {
                content: '';
                display: block;
                flex: none;
                width: 100%;
                height: 100%;
                padding: 5px 10px;
                text-align: center;
                white-space: nowrap;
        }
        #example-1 .state::before {
                content: 'Scroll →';
                background: red;
        }
        #example-1 .state::after {
                content: 'ON';
                background: green;
        }
        #example-1 .state::-webkit-scrollbar {
                display: none;
        }
    </style>
    <figcaption>
        Our initial scroll state element. <br/>
        The element must currently be scrolled manually to toggle the “state”.
    </figcaption>
</figure>
<pre class="language-css"><code class="language-css"><span class="token selector">.state</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 80px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
    <span class="token property">border-radius</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>
    <span class="token property">overflow-x</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>

    <span class="token selector">&amp;::before, &amp;::after</span> <span class="token punctuation">{</span>
        <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
        <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
        <span class="token property">flex</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token selector">&amp;::after</span> <span class="token punctuation">{</span>
        <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2>Altering State with Scroll-Snap</h2>
<p>Now that we’ve got an element maintaining our state through its scroll position, we can attempt to modify this state.</p>
<p>The scroll position, and thereby the state, can be changed temporarily through the application of scroll-snap.
Notably, the state remains preserved even after removing the scroll snapping declarations.</p>
<p>For illustrative purposes, in our example, we trigger scroll-snap on hover.
Nevertheless, for more complex scenarios, <a href="https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/">space-toggles</a> or <a href="https://kizu.dev/cyclic-toggles/">cyclic-toggles</a> can come in handy.</p>
<figure id="example-2">
    <div class="state"></div>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        #example-2 .state {
            display: flex;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            overflow-x: scroll;
            scrollbar-width: none;
            background: red;
            margin: 10px;
            font-size: 16px;
            line-height: 20px;
            color: white;
            scroll-snap-type: x mandatory;
        }
        #example-2 .state::before, 
        #example-2 .state::after {
                content: '';
                display: block;
                flex: none;
                width: 100%;
                height: 100%;
                padding: 5px 10px;
                text-align: center;
                white-space: nowrap;
        }
        #example-2 .state::before {
                content: 'Hover';
                background: red;
        }
        #example-2 .state::after {
                content: 'ON';
                background: green;
        }
        #example-2 .state:hover::after {
                scroll-snap-align: end;
        }
        #example-2 .state::-webkit-scrollbar {
                display: none;
        }
    </style>
    <figcaption>
        Try hovering the element to toggle the “state”.
    </figcaption>
</figure>
<pre class="language-css"><code class="language-css"><span class="token selector">.state</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token property">scroll-snap-type</span><span class="token punctuation">:</span> x mandatory<span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
    <span class="token selector">&amp;:hover::after</span> <span class="token punctuation">{</span>
        <span class="token property">scroll-snap-align</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2>Reading the state</h2>
<p>Awesome, we now have a mechanism to store and set the state. But, how do we read this state?</p>
<p>With the advent of scroll-driven animations,
we can use these as a means to interpret the state.
We can employ either a <code>view-timeline</code> or a <code>scroll-timeline</code> to expose the state’s value,
and with the use of <code>timeline-scope</code>, we can even elevate it to the root element if necessary.</p>
<p>I’ll use <a href="https://kizu.dev/cyclic-toggles/">cyclic toggles</a> to read the state as I think that’s neat,
but there are many ways to read out the state,
either by using <a href="https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/">space-toggles</a> or setting properties directly in the animation keyframes.</p>
<p><em>Note: Just as we can use multiple snap points to switch between more than two values,
cyclic toggles aren’t restricted to binary states.
As <a href="https://front-end.social/@kizu/110567336212936745">pointed out by Roman</a>,
they can play really well when we have multiple possible values.</em></p>
<figure id="example-3">
    <div class="use-state">
        <div class="state"></div>
    </div>
    <div class="has-support-info">&#9888; This demo requires support scroll-driven animations with timeline-scope. Try it out in Chrome Canary.</div>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        @keyframes read-state {
            contain 0% {
                --state: var(--state--off);
            }
            contain 100% {
                --state: var(--state--on);
            }
        }
        #example-3 .state {
            display: flex;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            overflow-x: scroll;
            scrollbar-width: none;
            background: red;
            margin: 10px;
            font-size: 16px;
            line-height: 20px;
            color: white;
            scroll-snap-type: x mandatory;
        }
        #example-3 .state::before,
        #example-3 .state::after {
            content: '';
            display: block;
            flex: none;
            width: 100%;
            height: 100%;
            padding: 5px 10px;
            text-align: center;
            white-space: nowrap;
        }
        #example-3 .state::before {
            content: 'Hover';
            background: red;
        }
        #example-3 .state::after {
            content: 'ON';
            background: green;
            view-timeline: --state-3-timeline inline;
        }
        #example-3 .state:hover::after {
            scroll-snap-align: end;
        }
        #example-3 .state::-webkit-scrollbar {
            display: none;
        }
        #example-3 .use-state {
            --state: var(--state--off);
            --state--off: var(--state, );
            --state--on: var(--state, );
            display: flow-root;
            height: 100px;
            timeline-scope: --state-3-timeline;
            animation: read-state;
            animation-timeline: --state-3-timeline;
            background: 
                var(--state--off, pink)
                var(--state--on, palegreen);
        }
    </style>
    <figcaption>
        Try hovering the element to toggle the “state”.
    </figcaption>
</figure>
<pre class="language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@keyframes</span> read-state</span> <span class="token punctuation">{</span>
    <span class="token selector">contain 0%</span> <span class="token punctuation">{</span>
        <span class="token property">--state</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state--off<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">contain 100%</span> <span class="token punctuation">{</span>
        <span class="token property">--state</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state--on<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">.state</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token selector">&amp;::after</span> <span class="token punctuation">{</span>
        <span class="token property">view-timeline</span><span class="token punctuation">:</span> --state-timeline inline<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">.use-state</span> <span class="token punctuation">{</span>
    <span class="token property">--state</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state--off<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">--state--off</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">--state--on</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">timeline-scope</span><span class="token punctuation">:</span> --state-timeline<span class="token punctuation">;</span>
    <span class="token property">animation</span><span class="token punctuation">:</span> read-state<span class="token punctuation">;</span>
    <span class="token property">animation-timeline</span><span class="token punctuation">:</span> --state-timeline<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state--off<span class="token punctuation">,</span> pink<span class="token punctuation">)</span> <span class="token function">var</span><span class="token punctuation">(</span>--state--on<span class="token punctuation">,</span> palegreen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2>Manipulating the state trough custom properties</h2>
<p>While directly writing the state with scroll-snap is effective, it can be a bit unwieldy.
A smoother alternative can be achieved by exposing custom properties,
which would then allow us to manipulate the state using <a href="https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/">space-toggles</a> instead.</p>
<p>In this case, we will use <code>--write-state-on: ;</code> to switch the state to on and <code>--write-state-off: ;</code> to transition the state to off.
This method allows us to manipulate the state externally, outside the confines of the state element itself.</p>
<pre class="language-css"><code class="language-css"><span class="token selector">.state</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token selector">&amp;::before</span> <span class="token punctuation">{</span>
        <span class="token property">scroll-snap-align</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--write-state-off<span class="token punctuation">)</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">&amp;::after</span> <span class="token punctuation">{</span>
        <span class="token property">scroll-snap-align</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--write-state-on<span class="token punctuation">)</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<figure id="example-4">
    <div class="use-state">
        <div class="state"></div>
        <div class="on"><span>ON</span></div>
        <div class="off"><span>OFF</span></div>
    </div>
    <div class="has-support-info">&#9888; This demo requires support scroll-driven animations with timeline-scope. Try it out in Chrome Canary.</div>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        @keyframes read-state {
            contain 0% {
                --state: var(--state--off);
            }
            contain 100% {
                --state: var(--state--on);
            }
        }
        #example-4 .state {
            display: flex;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            overflow-x: scroll;
            scrollbar-width: none;
            background: red;
            margin: 10px;
            font-size: 16px;
            line-height: 20px;
            color: white;
            scroll-snap-type: x mandatory;
        }
        #example-4 .state::before, 
        #example-4 .state::after {
            content: '';
            display: block;
            flex: none;
            width: 100%;
            height: 100%;
            padding: 5px 10px;
            text-align: center;
            white-space: nowrap;
        }
        #example-4 .state::before {
            content: 'OFF';
            background: red;
            scroll-snap-align: var(--write-state-off) start;
        }
        #example-4 .state::after {
            content: 'ON';
            background: green;
            view-timeline: --state-4-timeline inline;
            scroll-snap-align: var(--write-state-on) end;
        }
        #example-4 .state::-webkit-scrollbar {
            display: none;
        }
        #example-4 .on, 
        #example-4 .off {
            display: grid;
            width: 100px;
            height: 100px;
            margin: 10px;
            border-radius: 5px;
            place-content: center;
            color: #fff;
        }
        #example-4 .on { background: green; }
        #example-4 .off { background: red; }
        #example-4 :has(.on:hover) {
            --write-state-on: ;
        }
        #example-4 :has(.off:hover) {
            --write-state-off: ;
        }
        #example-4 .use-state {
            --state: var(--state--off);
            --state--off: var(--state, );
            --state--on: var(--state, );
            display: flow-root;
            timeline-scope: --state-4-timeline;
            animation: read-state;
            animation-timeline: --state-4-timeline;
            background: 
                var(--state--off, pink)
                var(--state--on, palegreen);
        }
    </style>
    <figcaption>
        Try hovering the ON and OFF elements to toggle the “state”.
    </figcaption>
</figure>
<h2>Trigger a state change using another scroll-timeline</h2>
<p>Now that we’ve delved into the depths of this outrageous hack and demonstrated that it’s possible to trigger the state change from outside the state element itself,
we can even go one step further.</p>
<p>Yes, brace yourself – we can trigger this state change from another scroll-driven animation.
In theory, we <em>could</em> use this to <a href="https://github.com/w3c/csswg-drafts/issues/7478">trigger a scroll-based animation once</a> – tempting, right?
But remember: just because you can do something, doesn’t mean you should.</p>
<figure id="example-5">
    <div class="read-and-write-state">
        <div class="state"></div>
    </div>
    <div class="has-support-info">&#9888; This demo requires support scroll-driven animations with timeline-scope. Try it out in Chrome Canary.</div>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        @keyframes read-state {
            contain 0% {
                --state: var(--state--off);
            }
            contain 100% {
                --state: var(--state--on);
            }
        }
        @keyframes write-state {
            100% {
                --write-state-on: ;
            }
        }
        #example-5 .state {
            display: flex;
            position: sticky;
            top: 10px;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            overflow-x: scroll;
            scrollbar-width: none;
            background: red;
            margin: 10px;
            font-size: 16px;
            line-height: 20px;
            color: white;
            scroll-snap-type: x mandatory;
        }
        #example-5 .state::before, 
        #example-5 .state::after {
            content: '';
            display: block;
            flex: none;
            width: 100%;
            height: 100%;
            padding: 5px 10px;
            text-align: center;
            white-space: nowrap;
        }
        #example-5 .state::before {
            content: 'OFF';
            background: red;
            scroll-snap-align: var(--write-state-off) start;
        }
        #example-5 .state::after {
            content: 'ON';
            background: green;
            view-timeline: --state-5-timeline inline;
            scroll-snap-align: var(--write-state-on) end;
        }
        #example-5 .state::-webkit-scrollbar {
            display: none;
        }
        #example-5 .read-and-write-state {
            --state: var(--state--off);
            --state--off: var(--state, );
            --state--on: var(--state, );
            display: grid;
            height: 100px;
            grid-template-rows: 200px;
            overflow-y: scroll;
            timeline-scope: --state-5-timeline;
            animation: write-state, read-state;
            animation-timeline: scroll(self block), --state-5-timeline;
            background: 
                var(--state--off, pink)
                var(--state--on, palegreen);
        }
    </style>
    <figcaption>
        Scroll down in the pink container to trigger a state change.
    </figcaption>
</figure>
<pre class="language-css"><code class="language-css">
<span class="token atrule"><span class="token rule">@keyframes</span> write-state</span> <span class="token punctuation">{</span>
    <span class="token selector">100%</span> <span class="token punctuation">{</span>
        <span class="token property">--write-state-on</span><span class="token punctuation">:</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">.read-and-write-state</span> <span class="token punctuation">{</span>
    <span class="token property">--state</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state--off<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">--state--off</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">--state--on</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--state<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">overflow-y</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>
    <span class="token property">timeline-scope</span><span class="token punctuation">:</span> --state-timeline<span class="token punctuation">;</span>
    <span class="token property">animation</span><span class="token punctuation">:</span> write-state<span class="token punctuation">,</span> read-state<span class="token punctuation">;</span>
    <span class="token property">animation-timeline</span><span class="token punctuation">:</span> <span class="token function">scroll</span><span class="token punctuation">(</span>self block<span class="token punctuation">)</span><span class="token punctuation">,</span> --state-timeline<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> 
        <span class="token function">var</span><span class="token punctuation">(</span>--state--off<span class="token punctuation">,</span> pink<span class="token punctuation">)</span>
        <span class="token function">var</span><span class="token punctuation">(</span>--state--on<span class="token punctuation">,</span> palegreen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2>Acknowledgments</h2>
<p>This exploration would not have been possible without the inspiration and groundbreaking work of many brilliant individuals in the field.
I would like to express my gratitude to:</p>
<ul>
<li>The team behind CSS Day, whose event sparked my curiosity and led me down this fascinating path.</li>
<li>Roman Komarov, who introduced us to the wonders of <a href="https://kizu.dev/cyclic-toggles/">Cyclic Toggles</a>.</li>
<li>Lea Verou and Ana Tudor, among others, who unveiled the power and potential of <a href="https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/">Space Toggles</a>.</li>
<li>Bramus, who cleverly found a way to hack modern CSS into supporting <a href="https://www.bram.us/2023/06/15/scroll-triggered-animations/">Scroll Triggered Animations</a>.</li>
</ul>
<p>Their contributions have significantly enriched our understanding of CSS and its capabilities. I am in awe of their ingenuity and thankful for their shared knowledge.</p>
<h2>TL;DR;</h2>
<p>With the advent of scroll-driven animations we can store, write and read state from a single div.
I’m not sure this is a good idea, but I think it’s a neat discovery.</p>
</div>
    </article>
  
    <footer>
      <h2>Johannes Odland</h2>
      <p>Infrequent posts about CSS and other frontend stuff.</p>
      <ul>
        <li><a href="https://front-end.social/@johannes">Mastodon</a></li>
        <li><a href="https://github.com/johannesodland">Github</a></li>
        <li><a href="/feed.xml">Atom feed</a></li>
      </ul>
      <p>Built with <a href="https://www.11ty.dev">Eleventy</a>.</p>
    </footer>
  </body>
</html>