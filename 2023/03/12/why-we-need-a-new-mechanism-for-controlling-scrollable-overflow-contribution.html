<!doctype html>
<html>
  <head>
      <meta charset=utf-8>
      <title>Why We Need a New Mechanism for Controlling Scrollable Overflow Contribution</title>
      <style>@layer reset, default, layout;</style>
      <link rel=stylesheet href=/assets/css/reset.css>
      <link rel=stylesheet href=/assets/css/fonts.css>
      <link rel=stylesheet href=/assets/css/default.css>
      <link rel=stylesheet href=/assets/css/layout.css>
      <link rel=stylesheet href=/assets/css/style.css>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel=canonical href="https://odland.dev/2023/03/12/why-we-need-a-new-mechanism-for-controlling-scrollable-overflow-contribution.html">
      <meta http-equiv="refresh" content="0; url=https://odland.dev/2023/03/12/why-we-need-a-new-mechanism-for-controlling-scrollable-overflow-contribution.html" />
      <link rel="me" href="https://front-end.social/@johannes">
  </head>
  <body>
  
   <header>
      <a href="/" class="site-title">Johannes Odland</a>
      <nav></nav>
    </header>

    <article role="main">
      <header>
        <time datetime="Sun Mar 12 2023 13:20:00 GMT+0000 (Coordinated Universal Time)" pubdate>
          Mar 12, 2023
        </time>
        <h1>Why We Need a New Mechanism for Controlling Scrollable Overflow Contribution</h1>
      </header>
      <div class="content"><style>
    .visible-scrollbars {
        scrollbar-color: lightgray dimgray;
        scrollbar-width: thin;
        scrollbar-gutter: stable;
    }
    .visible-scrollbars::-webkit-scrollbar {
        width: 8px; 
        height: 8px;
        background-color: lightgray;
    }
    .visible-scrollbars::-webkit-scrollbar-thumb {
        background: dimgray;
        border-radius: 2px;
    }
    fieldset {
        box-sizing: border-box;
        border: 3px solid transparent;
        border-radius: 3px;
        background: linear-gradient(to right, white, white), conic-gradient(rgb(69.6% 37.4% 48%), rgb(70% 40.1% 26.2%), rgb(59.1% 47.7% 11.8%), rgb(37.6% 54.8% 27.5%), rgb(0% 57.3% 50.1%), rgb(3.82% 54.2% 68.3%), rgb(39.1% 47.4% 74.8%), rgb(58.7% 40.8% 66.7%), rgb(69.6% 37.4% 48%));
        background: linear-gradient(to right, white, white), conic-gradient(in lch, lch(51 36.8 0), lch(51 36.8 90), lch(51 36.8 180), lch(51 36.8 270), lch(51 36.8 360));
        background: linear-gradient(to right, white, white), conic-gradient(in oklch, oklch(0.59 0.11 0), oklch(0.59 0.11 90), oklch(0.59 0.11 180), oklch(0.59 0.11 270), oklch(0.59 0.11 360));
        background-clip: padding-box, border-box;
        background-origin: border-box;
    }
    fieldset legend {
        background: white;
        padding: 0 10px;
    }
    figcaption {
        padding: 10px 0;
    }
    .has-suport-info {
        display: block;
        background: floralwhite;
        border: 2px solid lemonchiffon;
        padding: 10px;
    }
    @supports selector(:has(p)) {
        .has-suport-info {
            display: none;
        }
    }
    
</style>
<p>CSS is designed to ensure that content <a href="https://www.w3.org/TR/design-principles/#css-content-should-be-visible">is visible, accessible, and usable by default</a>.
When it comes to <a href="https://www.w3.org/TR/css-overflow-3/#scroll-container">scroll containers</a>,
this means that all descendant boxes should be viewable unless they are explicitly hidden.
To achieve this, the scrollbars in the container must allow the user to scroll around and see all the child elements.</p>
<p>However, there are cases such as decorative elements where we don’t necessarily want the entire element to be visible.
In this post, we’ll discuss ways to prevent the scrollable area from being extended.
We will also explore why we need a new way to control which elements will extend the scrollable area.</p>
<h2>The scrollable overflow area</h2>
<p>The rectangular area that the user can scroll around is called the <a href="https://www.w3.org/TR/css-overflow-3/#scrollable"><strong>scrollable overflow rectangle</strong></a>,
and it should be the smallest rectangle that can contain all the descendant boxes while still aligning with the container’s axes.
The combined area of all the descendant boxes is known as the <a href="https://www.w3.org/TR/css-overflow-3/#scrollable"><strong>scrollable overflow area</strong></a>.</p>
<p>As an example, lets take a scroll container that has a fixed size of <code>200px by 200px</code>.
It contains an element with dimensions of <code>50px by 50px</code> that is absolutely positioned at <code>top: &quot;200px; left:200px;</code>.
The <strong>scrollable overflow area</strong> will include the absolutely positioned child box,
and thus the <strong>scrollable overflow rectangle</strong> will have to be at least <code>250px by 250px</code> large.</p>
<figure>
<div id="example-1" class="visible-scrollbars">
    Scrollable overflow area will extend to include positioned element &#x2198;
    <div class="positioned"></div>
</div>
<style>
    #example-1 {
        position: relative;
        box-sizing: border-box;
        width: 200px;
        height: 200px;
        padding: 20px;
        overflow: scroll;
        background-color: thistle;
    }
    #example-1 .positioned {
        position: absolute;
        top: 200px;
        left: 200px;
        width: 50px;
        height: 50px;
        background-color: palevioletred;
    }
</style>
    <figcaption style="max-width: 300px;">
    The scrollable overflow rectangle is extended to include the absolute positioned element at (200px, 200px). 
    Scroll down to the bottom right corner to see the absolute positioned element.
    </figcaption>
</figure>
<p> </p>
<h2>The negative scrollable overflow region</h2>
<p>An area that automatically extends to contain your content is great,
but what if you want to fully or partially hide some content from visual readers?</p>
<p>One hack that was used historically was to place it beyond the top left corner.
Browsers didn’t provide a scrolling mechanism to access this area.
This meant that the content would be hidden from visible readers while remaining accessible to screen readers and search engines.</p>
<p>This corner is called the <a href="https://drafts.csswg.org/css-overflow-3/#scroll-origin"><strong>scroll origin</strong></a>, and as browsers now support different writing modes it will change position based on the writing mode.
The area beyond this corner is called the <a href="https://drafts.csswg.org/css-overflow-3/#negative-scrollable-overflow-region"><strong>negative scrollable overflow region</strong></a>,
and due to web compatibility the scrollable area will not be extended into this region.</p>
<p>While the negative scrollable overflow region can be used to partially or fully hide content,
it’s not very practical to use it for this purpose.
However, knowing that this region exists can help you understand why content sometimes is hidden and why the scrollable area is not extended to make it visible.</p>
<p><em>I hope that we can extend the scrollable area into this region in the future, as this <a href="https://github.com/w3c/csswg-drafts/issues/7885">could be beneficial for some scroll snapping use cases</a>.</em></p>
<figure>
<div id="example-2" class="visible-scrollbars">
    Scrollable overflow area will not include element positioned beyond the scroll origin &#x2196;
    <div class="positioned"></div>
</div>
<style>
    #example-2 {
        position: relative;
        box-sizing: border-box;
        width: 200px;
        height: 200px;
        padding: 20px;
        overflow: scroll;
        background-color: thistle;
    }
    #example-2 .positioned {
        position: absolute;
        top: -200px;
        left: -200px;
        width: 50px;
        height: 50px;
        background-color: palevioletred;
    }
</style>
    <figcaption style="max-width: 300px;">
    Example showing that the scrollable overflow rectangle is not extended to include the absolute positioned box at (-200px, -200px).
    </figcaption>
</figure>
<h2>Hiding or clipping overflow</h2>
<p>If we add a decorative element along one of the edges of our scroll container,
the scrollable area will grow to show the entire element, something that we didn’t intend.
We can prevent this by using CSS’s aptly named <code>overflow</code> property, which we’re already using to make the container scrollable.</p>
<p>We can clip the scrollable overflow area using <code>overflow: hidden</code> or, even better, <code>overflow: clip</code>.
The former allows scrolling by script, while the latter clips the overflow without creating a scroll container.
However, we can’t use these properties directly on our scrollable container because they would prevent scrolling.
Instead, we need to introduce a new element to contain the overflow.</p>
<p><em>Support for <code>clip</code> is growing, but you should probably add a fallback to <code>hidden</code> for older browsers.</em></p>
<p>While this is inconvenient, we can live with it.
But what if we could simply mark the decorative element as something that shouldn’t contribute to the scrollable overflow area?
This is the idea behind a proposed new CSS property, <code>overflow-contribution: none</code>. Check out the proposal <a href="https://github.com/w3c/csswg-drafts/issues/8361">here</a>.</p>
<figure id="example-3">
<div class="scroller visible-scrollbars">
    <div class="clipper">
        Overflow hidden will clip the absolute positioned element, 
        so that it does not contribute to the scrollable overflow area of the scroll container.
        <div class="positioned"></div>
    </div>
</div>
<fieldset style="max-width: 300px;">
    <legend>Overflow</legend>
    <label>
        <input type="radio" name="overflow1" value="visible">
        overflow: visible
    </label>
    <label>
        <input type="radio" name="overflow1" value="clip" checked>
        overflow: clip
    </label>
    <div class="has-suport-info">&#9888; This demo requires support for the `:has()` relational pseudo-class.</div>
</fieldset>
<style>
    #example-3 .scroller {
        position: relative;
        box-sizing: border-box;
        width: 200px;
        height: 200px;
        overflow: scroll;
        background-color: thistle;
    }
    #example-3 .clipper {
        position: relative;
        box-sizing: border-box;
        width: 100%;
        padding: 20px;
        overflow: visible;
    }
    #example-3:has(input[value="clip"]:checked) .clipper {
        overflow: hidden;
        overflow: clip;
    }
    #example-3 .positioned {
        position: absolute;
        top: 0;
        right: -25px;
        width: 50px;
        height: 25px;
        transform-origin: 50% 0;
        transform: rotate(45deg);
        background: linear-gradient(
            #e50000 0% 16.7%, 
            #ff8d00 16.7% 33.3%,
            #ffee00 33.3% 50%,
            #028121 50% 66.7%,
            #004cff 66.7% 83.3%,
            #770088 83.3% 100%);
    }
    #example-3 label {
        display: block;
    }
</style>
    <figcaption style="max-width: 300px;">
    An extra element with overflow: clip can be used to prevent a descendant element from extending the scrollable overflow rectangle.
    Use the radio-buttons to toggle between overflow: clip and overflow: visible to see the effect.
    </figcaption>
</figure>
<h2>When clipping breaks the content</h2>
<p>While <code>overflow: clip</code> can be a useful tool for preventing elements from contributing to the scrollable overflow area,
it has some limitations when it comes to 3D rendering contexts.
In a 3D rendering context, elements can be transformed in three dimensions, creating a sense of depth and perspective on the page.</p>
<p>However, when an element with <code>overflow: clip</code> is inserted into a scroll container that creates a 3D rendering context,
it prevents the descendant elements from participating in that context.
The result can be seen in the example below, where you can toggle <code>overflow: clip</code> on an element to see how it breaks the 3D rendering context.</p>
<p>This limitation occurs because <code>overflow: clip</code> (and <code>overflow: hidden</code>) are <a href="https://www.w3.org/TR/css-transforms-2/#grouping-property-values">grouping property values</a> that require the browser to create a flattened representation of the element before they can be applied.
This forces the used value of <code>preserve-3d</code> to be <code>flat</code>, effectively preventing the descendant elements from participating in the 3D rendering context.</p>
<p>As a result, <code>overflow: clip</code> and <code>overflow: hidden</code> cannot be used to prevent the elements from extending the scrollable overflow area in a 3D rendering context.
We have to explore other options to control the scrollable overflow region.</p>
<figure id="example-4">
<div class="scroller">
    <div class="clipper">
        <div class="background"></div>
        <div class="midground"></div>
        <div class="foreground"></div>
        <div class="content">
            Scrollable overflow 
        </div>
    </div>
</div>
<fieldset>
    <legend>Overflow</legend>
    <label>
        <input type="radio" name="overflow2" value="visible" checked>
        overflow: visible
    </label>
    <label>
        <input type="radio" name="overflow2" value="clip">
        overflow: clip
    </label>
    <div class="has-suport-info">&#9888; This demo requires support for the `:has()` relational pseudo-class.</div>
</fieldset>
<style>
    #example-4 .scroller {
        --camera-distance: 100;
        --height: 300px;
        container-type: size;
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: var(--height);
        overflow: scroll clip;
        background-color: thistle;
        transform-style: preserve-3d; 
        perspective: calc(1px * var(--camera-distance));
    }
    #example-4 .clipper {
        width: min-content;
        position: relative;
        transform-style: preserve-3d;
        overflow: visible;
    }
    #example-4:has(input[value="clip"]:checked) .clipper {
        overflow: clip;
    }
    #example-4 .background {
        --depth: 500;
        --scale: calc((var(--depth) + var(--camera-distance)) / var(--camera-distance));
        position: absolute;
        top: 0;
        left: 0;
        height: var(--height);
        width: calc(var(--height) / 512 * 1920);
        transform: scale(var(--scale)) translateZ(calc(-1px * var(--depth)));
        transform-origin: 50cqw calc(0.5 * var(--height));
        background: url(/assets/overflow-contribution/fjord-print-background.webp);
        background-size: 100%;
    }
    #example-4 .midground {
        --depth: 300;
        --scale: calc((var(--depth) + var(--camera-distance)) / var(--camera-distance));
        position: absolute;
        top: 0;
        left: 0;
        height: var(--height);
        width: calc(var(--height) / 512 * 1920);
        transform: scale(var(--scale)) translateZ(calc(-1px * var(--depth)));
        transform-origin: 50cqw calc(0.5 * var(--height));
        background: url(/assets/overflow-contribution/fjord-print-middleground.webp);
        background-size: 100%;
    }
    #example-4 .foreground {
        --depth: 200;
        --scale: calc((var(--depth) + var(--camera-distance)) / var(--camera-distance));
        position: absolute;
        top: 0;
        left: 0;
        height: var(--height);
        width: calc(var(--height) / 512 * 1920);
        transform: scale(var(--scale)) translateZ(calc(-1px * var(--depth)));
        transform-origin: 50cqw calc(0.5 * var(--height));
        background: url(/assets/overflow-contribution/fjord-print-foreground.webp);
        background-size: 100%;
    }
    #example-4 .content {
        box-sizing: border-box;
        height: var(--height);
        width: max-content;
        padding-left: 40px;
        padding-right: 40px;
        line-height: var(--height);
        font-size: calc(var(--height) / 2.5);
        font-family: Helvetica, sans-serif;
        font-weight: 600;
        letter-spacing: 12px;
        text-transform: uppercase;
        text-shadow: 0 0 30px #ffffff57;
        -webkit-text-stroke-width: 4px;
        -webkit-text-stroke-color: #0c0042;
        border: 10px solid #0c0042;
        color: rgba(168,194,253,0.6);
        transform: translateZ(0);
    }
</style>
    <figcaption>
        Scroll to the right to see how far the scrollable overflow area has been extended. 
        With overflow: clip the scrollable overflow area is prevented from growing to include the background elements, 
        but it removes the background elements from the 3d rendering context. 
        Without overflow: clip the scrollable overflow area is extended to show all the background elements, 
        something that is not desired.
        <br/>
        <small>Illustration: Created with the assistance of DALL·E 2</small>
    </figcaption>
</figure>
<h2>Are there any other solutions?</h2>
<p>Currently, there are no known solutions to prevent 3D transformed elements from contributing to scrollable overflow.
The only option is to size these elements to fit within the scrollable overflow area needed by the main content.</p>
<p>Unfortunately,
only Firefox seem to take the perspective transform into account when calculating the size of the scrollable overflow area.
In other browsers the scrollable overflow area are extended without taking perspective and the current scrollTop into account.</p>
<p>In the example below we have sized the content participating in the 3d rendering context so that it will not extend
the scrollable overflow area when scrolled all the way to the right.
As we mentioned above, only Firefox will calculate the scrollable overflow area correctly.</p>
<p><em>If you want browsers to handle perspective when calculating scrollable overflow, you should star these issues:
<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=643213">643213</a>
<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1264086">1264086</a>
<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1011442">1011442</a></em></p>
<p><em>Calculating the appropriate size of a z-translated element to fit within the main content is a topic for a future post..</em></p>
<figure id="example-5">
<div class="scroller">
    <div class="clipper">
        <div class="background"></div>
        <div class="midground"></div>
        <div class="foreground"></div>
        <div class="content">
            Scrollable overflow 
        </div>
    </div>
</div>
<style>
    #example-5 .scroller {
        --camera-distance: 100;
        --height: 300px;
        container-type: size;
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: var(--height);
        overflow: scroll clip;
        background-color: thistle;
        transform-style: preserve-3d; 
        perspective: calc(1px * var(--camera-distance));
    }
    #example-5 .clipper {
        width: min-content;
        position: relative;
        transform-style: preserve-3d;
    }
    #example-5 .background {
        --depth: 500;
        --scale: calc((var(--depth) + var(--camera-distance)) / var(--camera-distance));
        position: absolute;
        top: 0;
        left: 0;
        height: var(--height);
        width: calc(100% / var(--scale) + 100cqw / var(--scale) * var(--depth) / var(--camera-distance));
        transform: scale(var(--scale)) translateZ(calc(-1px * var(--depth)));
        transform-origin: 50cqw calc(0.5 * var(--height));
        background: url(/assets/overflow-contribution/fjord-print-background.webp);
        background-size: auto 100%;
    }
    #example-5 .midground {
        --depth: 300;
        --scale: calc((var(--depth) + var(--camera-distance)) / var(--camera-distance));
        position: absolute;
        top: 0;
        left: 0;
        height: var(--height);
        width: calc(100% / var(--scale) + 100cqw / var(--scale) * var(--depth) / var(--camera-distance));
        transform: scale(var(--scale)) translateZ(calc(-1px * var(--depth)));
        transform-origin: 50cqw calc(0.5 * var(--height));
        background: url(/assets/overflow-contribution/fjord-print-middleground.webp);
        background-size: 100%;
    }
    #example-5 .foreground {
        --depth: 200;
        --scale: calc((var(--depth) + var(--camera-distance)) / var(--camera-distance));
        position: absolute;
        top: 0;
        left: 0;
        height: var(--height);
        width: calc(100% / var(--scale) + 100cqw / var(--scale) * var(--depth) / var(--camera-distance));
        transform: scale(var(--scale)) translateZ(calc(-1px * var(--depth)));
        transform-origin: 50cqw calc(0.5 * var(--height));
        background: url(/assets/overflow-contribution/fjord-print-foreground.webp);
        background-size: 100%;
    }
    #example-5 .content {
        box-sizing: border-box;
        height: var(--height);
        width: max-content;
        padding-left: 40px;
        padding-right: 40px;
        line-height: var(--height);
        font-size: calc(var(--height) / 2.5);
        font-family: Helvetica, sans-serif;
        font-weight: 600;
        letter-spacing: 12px;
        text-transform: uppercase;
        text-shadow: 0 0 30px #ffffff57;
        -webkit-text-stroke-width: 4px;
        -webkit-text-stroke-color: #0c0042;
        border: 10px solid #0c0042;
        color: rgba(168,194,253,0.6);
        transform: translateZ(0);
    }
</style>
    <figcaption>
        Scroll to the right to see how far the scrollable overflow area has been extended. 
        The background elements are sizes so that they will not extend further than the main content when scrolled to the right.
        Unfortunately only Firefox seem to take the perspective transform into account when extending the scrollable overflow area.
        <br/>
        <small>Illustration: Created with the assistance of DALL·E 2</small>
    </figcaption>
</figure>
<h2>Could there be a better solution?</h2>
<p>For some content, there’s no need to extend the scrollable overflow area.
If we could mark these elements,
the browser could simply skip them when calculating the scrollable overflow area.
This would save resources as well as solving our problem.</p>
<p>I have <a href="https://github.com/w3c/csswg-drafts/issues/8361">proposed to add a method to prevent elements from contributing to scrollable overflow</a>,
and the CSS Working Group has fortunately resolved to add such a feature.</p>
<p>One day in the future we might be able to mark elements using <code>overflow-contribution: none</code>, <code>contain: overflow-contribution</code> or something similar.</p>
<h2>TL;DR</h2>
<p>By default, the scrollable overflow area of a scroll container extends to include all descendant elements.
While we can use <code>overflow: clip</code> and <code>overflow: hidden</code> to somewhat control this area,
it might require adding extra elements
and cannot be used if descendant elements are participating in a 3d rendering context created by the scroll container.</p>
<p>To address this issue I have argued for the need to mark elements that should not contribute to the scrollable overflow area by setting a property like <code>overflow-contribution: none</code>.
Fortunately, the CSSWG <a href="https://github.com/w3c/csswg-drafts/issues/8361">has resolved to add such a feature</a> to CSS Overflow Module Level 4.</p>
</div>
    </article>
  
    <footer>
      <h2>Johannes Odland</h2>
      <p>Infrequent posts about CSS and other frontend stuff.</p>
      <ul>
        <li><a href="https://front-end.social/@johannes">Mastodon</a></li>
        <li><a href="https://github.com/johannesodland">Github</a></li>
        <li><a href="/feed.xml">Atom feed</a></li>
      </ul>
      <p>Built with <a href="https://www.11ty.dev">Eleventy</a>.</p>
    </footer>
  </body>
</html>